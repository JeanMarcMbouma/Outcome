using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Text;

namespace BbQ.Outcome.SourceGenerators
{
    /// <summary>
    /// Source generator that creates Error helper properties for enums marked with [QbqOutcome].
    /// </summary>
    [Generator]
    public class OutcomeSourceGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            // Register a syntax receiver for enums with the QbqOutcome attribute
            var enumDeclarations = context.SyntaxProvider
                .CreateSyntaxProvider(
                    predicate: static (s, _) => IsCandidateSyntax(s),
                    transform: static (ctx, _) => GetEnumWithAttribute(ctx))
                .Where(static m => m is not null);

            context.RegisterSourceOutput(enumDeclarations,
                static (spc, enumDecl) => Execute(spc, enumDecl!));
        }

        private static bool IsCandidateSyntax(SyntaxNode node)
        {
            return node is EnumDeclarationSyntax enumDecl &&
                   enumDecl.AttributeLists.Count > 0;
        }

        private static EnumDeclarationSyntax? GetEnumWithAttribute(GeneratorSyntaxContext context)
        {
            var enumDecl = (EnumDeclarationSyntax)context.Node;

            // Check if this enum has the QbqOutcome attribute
            foreach (var attributeList in enumDecl.AttributeLists)
            {
                foreach (var attribute in attributeList.Attributes)
                {
                    var attributeName = GetAttributeName(attribute);
                    if (attributeName == "QbqOutcome" || attributeName == "QbqOutcomeAttribute")
                    {
                        return enumDecl;
                    }
                }
            }

            return null;
        }

        private static string GetAttributeName(AttributeSyntax attribute)
        {
            return attribute.Name switch
            {
                IdentifierNameSyntax ins => ins.Identifier.ValueText,
                QualifiedNameSyntax qns => qns.Right.Identifier.ValueText,
                _ => string.Empty
            };
        }

        private static void Execute(SourceProductionContext context, EnumDeclarationSyntax enumDecl)
        {
            // Check if the enum is within a namespace (either regular or file-scoped)
            var parent = enumDecl.Parent;
            NamespaceDeclarationSyntax? namespaceDecl = null;
            FileScopedNamespaceDeclarationSyntax? fileScopedNamespaceDecl = null;
            
            while (parent != null)
            {
                if (parent is NamespaceDeclarationSyntax nsd)
                {
                    namespaceDecl = nsd;
                    break;
                }
                if (parent is FileScopedNamespaceDeclarationSyntax fsnd)
                {
                    fileScopedNamespaceDecl = fsnd;
                    break;
                }
                parent = parent.Parent;
            }

            // If no namespace found, skip generation
            if (namespaceDecl == null && fileScopedNamespaceDecl == null)
            {
                return;
            }

            var namespaceName = GetNamespaceName(enumDecl);
            var enumName = enumDecl.Identifier.ValueText;
            var enumMembers = enumDecl.Members;

            var sb = new StringBuilder();
            sb.AppendLine("// <auto-generated />");
            sb.AppendLine("#nullable enable");
            sb.AppendLine();
            sb.AppendLine("using BbQ.Outcome;");
            sb.AppendLine($"namespace {namespaceName}");
            sb.AppendLine("{");
            sb.AppendLine($"    /// <summary>");
            sb.AppendLine($"    /// Error helper properties for {enumName} enum.");
            sb.AppendLine($"    /// This class is auto-generated by the Outcome source generator.");
            sb.AppendLine($"    /// </summary>");
            sb.AppendLine($"    public static class {enumName}Errors");
            sb.AppendLine("    {");

            foreach (var member in enumMembers)
            {
                if (member is EnumMemberDeclarationSyntax enumMember)
                {
                    var memberName = enumMember.Identifier.ValueText;
                    var description = ExtractDescription(enumMember);
                    var severity = ExtractSeverity(enumMember);
                    var propertyName = $"{memberName}Error";

                    sb.AppendLine($"        /// <summary>");
                    sb.AppendLine($"        /// Creates an Error for the {memberName} enum value.");
                    sb.AppendLine($"        /// </summary>");
                    sb.AppendLine($"        public static Error<{enumName}> {propertyName} =>");
                    sb.AppendLine($"            new(");
                    sb.AppendLine($"                {enumName}.{memberName},");
                    sb.AppendLine($"                \"{description}\",");
                    sb.AppendLine($"                ErrorSeverity.{severity}");
                    sb.AppendLine($"            );");
                    sb.AppendLine();
                }
            }

            sb.AppendLine("    }");
            sb.AppendLine("}");

            context.AddSource($"{enumName}Errors.g.cs", sb.ToString());
        }

        private static string GetNamespaceName(EnumDeclarationSyntax enumDecl)
        {
            var parent = enumDecl.Parent;
            while (parent != null)
            {
                if (parent is NamespaceDeclarationSyntax namespaceSyntax)
                {
                    return namespaceSyntax.Name.ToString();
                }
                if (parent is FileScopedNamespaceDeclarationSyntax fileScopedNamespace)
                {
                    return fileScopedNamespace.Name.ToString();
                }
                parent = parent.Parent;
            }
            return "BbQ.Outcome";
        }

        private static string ExtractDescription(EnumMemberDeclarationSyntax member)
        {
            // Try to extract description from XML documentation
            var leadingTrivia = member.GetLeadingTrivia();
            foreach (var trivia in leadingTrivia)
            {
                if (trivia.IsKind(SyntaxKind.SingleLineDocumentationCommentTrivia))
                {
                    var text = trivia.ToString();
                    // Simple extraction: look for summary tags
                    var lines = text.Split(new[] { "\r\n", "\r", "\n" }, StringSplitOptions.None);
                    var summaryLines = new List<string>();
                    var inSummary = false;

                    foreach (var line in lines)
                    {
                        var trimmed = line.Trim();
                        if (trimmed.Contains("<summary>"))
                        {
                            inSummary = true;
                            var content = trimmed.Replace("///", "").Replace("<summary>", "").Replace("</summary>", "").Trim();
                            if (!string.IsNullOrEmpty(content))
                                summaryLines.Add(content);
                        }
                        else if (trimmed.Contains("</summary>"))
                        {
                            inSummary = false;
                        }
                        else if (inSummary && !string.IsNullOrEmpty(trimmed))
                        {
                            var content = trimmed.Replace("///", "").Trim();
                            if (!string.IsNullOrEmpty(content))
                                summaryLines.Add(content);
                        }
                    }

                    if (summaryLines.Count > 0)
                    {
                        return string.Join(" ", summaryLines).Trim();
                    }
                }
            }

            // Fallback: use member name
            return member.Identifier.ValueText;
        }

        private static string ExtractSeverity(EnumMemberDeclarationSyntax member)
        {
            // Look for ErrorSeverity attribute on the enum member
            foreach (var attributeList in member.AttributeLists)
            {
                foreach (var attribute in attributeList.Attributes)
                {
                    var attributeName = GetAttributeName(attribute);
                    if (attributeName == "ErrorSeverity" || attributeName == "ErrorSeverityAttribute")
                    {
                        // Try to extract the severity value from the attribute argument
                        if (attribute.ArgumentList?.Arguments.Count > 0)
                        {
                            var arg = attribute.ArgumentList.Arguments[0];
                            var argText = arg.Expression.ToString();
                            
                            // Handle different formats: ErrorSeverity.Warning, "Warning", Warning
                            if (argText.Contains("."))
                            {
                                // Format: ErrorSeverity.Warning
                                return argText.Split('.').Last();
                            }
                            else if (argText.StartsWith("\"") && argText.EndsWith("\""))
                            {
                                // Format: "Warning"
                                return argText.Trim('"');
                            }
                            else
                            {
                                // Format: Warning
                                return argText;
                            }
                        }
                    }
                }
            }

            // Default to Error if no attribute is specified
            return "Error";
        }
    }
}
